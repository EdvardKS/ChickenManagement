import { type Request, Response, NextFunction } from 'express';
import { storage } from '../storage';
import { type Stock, type StockHistory } from '@shared/schema';

type StockAction = 
  | 'add_mounted'  // Para modificar stock montado (initial_stock)
  | 'remove_mounted'
  | 'mounted_correction' // Para correcciones de stock montado
  | 'direct_sale'  // Para ventas sin encargo (current_stock)
  | 'direct_sale_correction'
  | 'new_order'    // Para pedidos (reserved_stock)
  | 'cancel_order'
  | 'order_delivered'
  | 'order_error'
  | 'order_update'
  | 'reset_stock';

interface StockUpdate {
  initialStock: number;
  currentStock: number;
  reservedStock: number;
  unreservedStock: number;
  action: StockAction;
  quantity: number;  // Siempre esperamos un n√∫mero
  source?: 'admin' | 'client';
}

export async function stockMiddleware(
  req: Request & { stockUpdate?: StockUpdate },
  _res: Response,
  next: NextFunction
) {
  try {
    const stockUpdate = req.stockUpdate;
    if (!stockUpdate) {
      console.log('üìå STOCK MIDDLEWARE - No hay actualizaci√≥n de stock, continuando');
      return next();
    }

    console.log('üîÑ STOCK MIDDLEWARE - Procesando actualizaci√≥n:', JSON.stringify(stockUpdate, null, 2));
    
    // Validar los datos recibidos
    if (typeof stockUpdate.initialStock !== 'number') {
      console.error('‚ùå STOCK MIDDLEWARE - Error: initialStock debe ser un n√∫mero:', stockUpdate.initialStock, typeof stockUpdate.initialStock);
      throw new Error(`initialStock debe ser un n√∫mero, recibido: ${typeof stockUpdate.initialStock}`);
    }
    
    if (typeof stockUpdate.currentStock !== 'number') {
      console.error('‚ùå STOCK MIDDLEWARE - Error: currentStock debe ser un n√∫mero:', stockUpdate.currentStock, typeof stockUpdate.currentStock);
      throw new Error(`currentStock debe ser un n√∫mero, recibido: ${typeof stockUpdate.currentStock}`);
    }
    
    if (typeof stockUpdate.reservedStock !== 'number') {
      console.error('‚ùå STOCK MIDDLEWARE - Error: reservedStock debe ser un n√∫mero:', stockUpdate.reservedStock, typeof stockUpdate.reservedStock);
      throw new Error(`reservedStock debe ser un n√∫mero, recibido: ${typeof stockUpdate.reservedStock}`);
    }
    
    if (typeof stockUpdate.unreservedStock !== 'number') {
      console.error('‚ùå STOCK MIDDLEWARE - Error: unreservedStock debe ser un n√∫mero:', stockUpdate.unreservedStock, typeof stockUpdate.unreservedStock);
      throw new Error(`unreservedStock debe ser un n√∫mero, recibido: ${typeof stockUpdate.unreservedStock}`);
    }
    
    if (typeof stockUpdate.quantity !== 'number') {
      console.error('‚ùå STOCK MIDDLEWARE - Error: quantity debe ser un n√∫mero:', stockUpdate.quantity, typeof stockUpdate.quantity);
      throw new Error(`quantity debe ser un n√∫mero, recibido: ${typeof stockUpdate.quantity}`);
    }

    // Obtener el stock actual
    console.log('üîç STOCK MIDDLEWARE - Obteniendo stock actual de la base de datos');
    const currentStock = await storage.getCurrentStock();
    
    if (!currentStock) {
      console.error('‚ùå STOCK MIDDLEWARE - Error: No se encontr√≥ ning√∫n registro de stock en la base de datos');
      throw new Error('No se encontr√≥ ning√∫n registro de stock. Inicializa el stock primero.');
    }
    
    console.log('üìä STOCK MIDDLEWARE - Stock actual encontrado:', JSON.stringify(currentStock, null, 2));

    // Extraer solo los campos permitidos para la actualizaci√≥n del stock
    const { initialStock, currentStock: newCurrentStock, reservedStock, unreservedStock } = stockUpdate;

    // Convertir expl√≠citamente a strings para asegurar compatibilidad
    const newStock: Partial<Stock> = {
      initialStock: initialStock.toString(),
      currentStock: newCurrentStock.toString(),
      reservedStock: reservedStock.toString(),
      unreservedStock: unreservedStock.toString(),
      lastUpdated: new Date()
    };

    console.log('üîÑ STOCK MIDDLEWARE - Actualizando stock con:', JSON.stringify(newStock, null, 2));

    try {
      const updatedStock = await storage.updateStock(newStock);
      console.log('‚úÖ STOCK MIDDLEWARE - Stock actualizado correctamente:', JSON.stringify(updatedStock, null, 2));
      
      // Crear entrada en el historial
      console.log('üìù STOCK MIDDLEWARE - Registrando historial de cambio');
      try {
        const stockHistoryEntry = {
          id: 0, // La base de datos generar√° el ID real
          stockId: updatedStock.id,
          action: stockUpdate.action,
          quantity: stockUpdate.quantity.toString(),
          previousStock: currentStock.currentStock,
          newStock: updatedStock.currentStock,
          createdBy: stockUpdate.source || 'system',
          createdAt: new Date()
        };
        
        console.log('üìù STOCK MIDDLEWARE - Datos del historial:', JSON.stringify(stockHistoryEntry, null, 2));
        
        await storage.createStockHistory(stockHistoryEntry);
        console.log('‚úÖ STOCK MIDDLEWARE - Historial registrado correctamente');
      } catch (historyError: any) {
        console.error('‚ö†Ô∏è STOCK MIDDLEWARE - Error al crear historial:', historyError);
        // No detenemos el flujo por un error en el historial, solo lo registramos
      }
      
      next();
    } catch (dbError: any) {
      console.error('‚ùå STOCK MIDDLEWARE - Error al actualizar la base de datos:', dbError);
      throw new Error(`Error al actualizar stock: ${dbError.message}`);
    }
  } catch (error: any) {
    console.error('‚ùå STOCK MIDDLEWARE - Error general:', error);
    console.error('‚ùå STOCK MIDDLEWARE - Detalles:', {
      message: error.message,
      stack: error.stack,
      stockUpdate: req.stockUpdate
    });
    
    // Crear un error con informaci√≥n detallada
    const enhancedError = new Error(`Error en gesti√≥n de stock: ${error.message}`);
    (enhancedError as any).details = {
      originalError: error.message,
      stockData: req.stockUpdate,
      errorCode: 'STOCK_MIDDLEWARE_ERROR'
    };
    
    next(enhancedError);
  }
}

export async function prepareStockUpdate(
  action: StockAction,
  quantity: number | string,
  source?: 'admin' | 'client',
  isPastOrder: boolean = false
): Promise<StockUpdate> {
  console.log('üîÑ PREPARE STOCK - Iniciando preparaci√≥n de actualizaci√≥n de stock');
  console.log('üîÑ PREPARE STOCK - Par√°metros recibidos:', {
    action,
    quantity,
    quantityType: typeof quantity,
    source,
    isPastOrder
  });
  
  try {
    const currentStock = await storage.getCurrentStock();
    
    if (!currentStock) {
      console.error('‚ùå PREPARE STOCK - Error: No se encontr√≥ ning√∫n registro de stock en la base de datos');
      throw new Error('No se encontr√≥ ning√∫n registro de stock. Inicializa el stock primero.');
    }
    
    console.log('üìä PREPARE STOCK - Stock actual:', JSON.stringify(currentStock, null, 2));
    
    // Asegurar que quantity es un n√∫mero
    let quantityNum: number;
    
    try {
      if (typeof quantity === 'string') {
        console.log('üîÑ PREPARE STOCK - Convirtiendo cantidad de string a n√∫mero:', quantity);
        quantityNum = parseFloat(quantity);
      } else {
        console.log('üîÑ PREPARE STOCK - Asegurando que cantidad es un n√∫mero:', quantity);
        quantityNum = Number(quantity);
      }
      
      console.log('üîÑ PREPARE STOCK - Cantidad convertida:', quantityNum, typeof quantityNum);
      
      if (isNaN(quantityNum)) {
        throw new Error(`Valor no num√©rico: ${quantity}`);
      }
      
      if (quantityNum < 0) {
        throw new Error(`Cantidad negativa no permitida: ${quantityNum}`);
      }
    } catch (conversionError: any) {
      console.error('‚ùå PREPARE STOCK - Error al convertir cantidad:', conversionError);
      console.error('‚ùå PREPARE STOCK - Detalles de cantidad:', { 
        original: quantity, 
        type: typeof quantity 
      });
      throw new Error(`Cantidad inv√°lida: "${quantity}". Se espera un n√∫mero v√°lido. Error: ${conversionError.message}`);
    }
    
    console.log('üìä PREPARE STOCK - Estado actual:', {
      current: currentStock,
      action,
      quantity: quantityNum,
      quantityOriginal: quantity,
      isPastOrder
    });

    // Si es un pedido de d√≠as pasados, permitimos operaciones especiales
    if (isPastOrder) {
      console.log('üïí PREPARE STOCK - Procesando pedido de d√≠a pasado');
      // Para pedidos pasados, no afectamos el stock actual
      return {
        initialStock: parseFloat(currentStock.initialStock),
        currentStock: parseFloat(currentStock.currentStock),
        reservedStock: parseFloat(currentStock.reservedStock),
        unreservedStock: parseFloat(currentStock.unreservedStock),
        action,
        quantity: quantityNum,  // Usar el valor num√©rico convertido
        source
      };
    }

    // Convertir todos los valores a n√∫meros, asegur√°ndonos de que sean valores v√°lidos
    const initial = parseFloat(currentStock.initialStock);
    const current = parseFloat(currentStock.currentStock);
    const reserved = parseFloat(currentStock.reservedStock);
    
    // Verificar que los valores convertidos son v√°lidos
    if (isNaN(initial) || isNaN(current) || isNaN(reserved)) {
      throw new Error(`Valores de stock inv√°lidos: initialStock=${currentStock.initialStock}, currentStock=${currentStock.currentStock}, reservedStock=${currentStock.reservedStock}`);
    }

    let newInitial = initial;
    let newCurrent = current;
    let newReserved = reserved;

    switch (action) {
      case 'direct_sale':
        // Solo reduce el stock actual para ventas sin encargo
        newCurrent = Math.max(0, current - quantityNum);
        console.log('üõí PREPARE STOCK - Venta directa:', {
          oldCurrent: current,
          quantity: quantityNum,
          newCurrent
        });
        break;
      case 'direct_sale_correction':
        // Solo aumenta el stock actual (correcci√≥n)
        newCurrent = current + quantityNum;
        console.log('üîÑ PREPARE STOCK - Correcci√≥n de venta:', {
          oldCurrent: current,
          quantity: quantityNum,
          newCurrent
        });
        break;
      case 'add_mounted':
        // Actualiza initial_stock (pollos montados) y current_stock
        newInitial = initial + quantityNum;
        newCurrent = current + quantityNum; // Tambi√©n incrementamos current_stock
        console.log('‚ûï PREPARE STOCK - Pollos montados a√±adidos:', {
          oldInitial: initial,
          oldCurrent: current,
          quantity: quantityNum,
          newInitial,
          newCurrent
        });
        break;
      case 'remove_mounted':
        // Actualiza initial_stock (correcci√≥n de pollos montados) y current_stock
        newInitial = Math.max(0, initial - quantityNum);
        newCurrent = Math.max(0, current - quantityNum); // Tambi√©n decrementamos current_stock
        console.log('‚ûñ PREPARE STOCK - Correcci√≥n de pollos montados:', {
          oldInitial: initial,
          oldCurrent: current,
          quantity: quantityNum,
          newInitial,
          newCurrent
        });
        break;
      case 'new_order':
        // Solo aumenta el stock reservado (pedidos)
        newReserved = reserved + quantityNum;
        console.log('üìù PREPARE STOCK - Nuevo pedido:', {
          oldReserved: reserved,
          quantity: quantityNum,
          newReserved
        });
        break;
      case 'cancel_order':
        // Solo reduce el stock reservado (cancelaci√≥n de pedidos)
        newReserved = Math.max(0, reserved - quantityNum);
        console.log('‚ùå PREPARE STOCK - Pedido cancelado:', {
          oldReserved: reserved,
          quantity: quantityNum,
          newReserved
        });
        break;
      case 'order_delivered':
        // Reduce el stock actual y reservado (entrega de pedidos)
        newCurrent = Math.max(0, current - quantityNum);
        newReserved = Math.max(0, reserved - quantityNum);
        console.log('‚úÖ PREPARE STOCK - Pedido entregado:', {
          oldCurrent: current,
          oldReserved: reserved,
          quantity: quantityNum,
          newCurrent,
          newReserved
        });
        break;
      case 'order_error':
        // Solo reduce el stock reservado (pedido con error)
        newReserved = Math.max(0, reserved - quantityNum);
        console.log('‚ö†Ô∏è PREPARE STOCK - Pedido con error:', {
          oldReserved: reserved,
          quantity: quantityNum,
          newReserved
        });
        break;
      case 'order_update':
        // Actualiza el stock reservado (modificaci√≥n de pedido)
        // quantity aqu√≠ representa la diferencia (nuevo - antiguo)
        newReserved = Math.max(0, reserved + quantityNum);
        console.log('üîÑ PREPARE STOCK - Pedido actualizado:', {
          oldReserved: reserved,
          quantity: quantityNum,
          newReserved
        });
        break;
      case 'reset_stock':
        // Resetea todos los valores a 0
        newInitial = 0;
        newCurrent = 0;
        newReserved = 0;
        console.log('üîÑ PREPARE STOCK - Reseteando stock:', {
          oldInitial: initial,
          oldCurrent: current,
          oldReserved: reserved,
          newInitial,
          newCurrent,
          newReserved
        });
        break;
    }

    // Crear el objeto de actualizaci√≥n usando el valor num√©rico convertido para quantity
    const update: StockUpdate = {
      initialStock: newInitial,
      currentStock: newCurrent,
      reservedStock: newReserved,
      unreservedStock: Math.max(0, newCurrent - newReserved),
      action,
      quantity: quantityNum,  // Usar el valor num√©rico convertido
      source
    };

    console.log('‚úÖ PREPARE STOCK - Actualizaci√≥n preparada:', update);
    return update;
  } catch (error: any) {
    console.error('‚ùå PREPARE STOCK - Error general:', error);
    console.error('‚ùå PREPARE STOCK - Detalles del error:', {
      message: error.message,
      stack: error.stack,
      action,
      quantity
    });
    throw new Error(`Error al preparar actualizaci√≥n de stock: ${error.message}`);
  }
}